
pragma solidity ^0.8.20;

contract ZenLibrary1 {
    string public data;

    constructor() {
        data = "iable} * ${o} * ${u};\\n${n.varKeyword} ${c} = 10 * ${i[3].variable} * ${s} * ${m};\\n${n.varKeyword} ${p} = 5 * ${i[4].variable} * ${m} * ${u};\\n${n.varKeyword} ${b} = ${i[5].variable} * ${m} * ${m};\\n\\n${n.varKeyword} ${r} = ${$} + ${d} + ${h} + ${c} + ${p} + ${b};\\n`),n.emit(y,r,a,...i)},xe=(e,t=1e4,n=1e4,a=.8,i=1e4,r=4e3)=>s=>{let o=s.gen(e),l=s.gen(t),u=s.gen(n),m=s.gen(a),$=s.gen(i),d=s.gen(r),h=s.alloc(1),c=s.alloc(1),p=s.alloc(1),b=s.alloc(1),[y,f,g]=s.useVariables(\"trigger\",\"adsrVal\",\"counter\"),v=`\\nlet ${y} = ${o.variable} || memory[${p.idx}];\\nif (${y} && memory[${h.idx}] > 0) {\\n    // we are mid way thru\\n    // we need to decrease\\n    // we want to cancel it in 2 ms ~ 100 samples\\n    memory[${b.idx}] = memory[${h.idx}]/300;\\n}\\n\\nlet ${f} = 0;\\nif (memory[${b.idx}] > 0) {\\n  ${f} = memory[${h.idx}] - memory[${b.idx}];\\n  if (${f} <= 0) {\\n    memory[${b.idx}] = 0;\\n    memory[${p.idx}] = 1;\\n  }\\n} else { \\n    let ${g} = ${y} > 0 ? 0 : memory[${c.idx}];\\n    memory[${c.idx}] = ${g} + 1;\\n\\n    if (memory[${p.idx}] > 0) {\\n       memory[${p.idx}] = 0;\\n    }\\n    \\n    if (${g} > ${d.variable} && ${g} < ${d.variable} + ${$.variable}) {\\n        // release\\n        let releaseCounter = ${g} - ${d.variable};\\n        let releaseRatio = releaseCounter / ${$.variable};\\n        ${f} = ${m.variable}* (1 - releaseRatio);\\n    }else if (${g} <${l.variable}) {\\n        // attack \\n        ${f} = ${g} / ${l.variable};\\n    } else if (${g} <${l.variable} + ${u.variable}) {\\n        // decay\\n        let decayCounter = ${g} - ${l.variable};\\n        let decayRatio = decayCounter / ${u.variable};\\n        // lerp between 1  and sustain\\n        ${f} = 1 * (1 - decayRatio) + decayRatio * ${m.variable};\\n    } else if (${g} <${d.variable}) {\\n        // sustain\\n        ${f} = ${m.variable};\\n    } //else if (${g} < ${d.variable} + ${$.variable}) {\\n   // }\\n}\\nmemory[${h.idx}] = ${f};\\n`;return s.emit(v,f,o,l,u,m,$,d)},we=(...e)=>t=>{let n=e.map((e=>t.gen(e))),a=`\\nconsole.log(${n.map((e=>e.variable)).join(\",\")});\\n        `;return t.emit(a,n[0].variable,...n)},Me=(e,t)=>n=>{let a=n.gen(e),i=`output${t}`,r=`\\n${i} = ${a.variable};\\n`,s=n.emit(r,i,a);return s.outputs=t,s},_e=(e,t)=>n=>{let[a]=n.useVariables(e),i=n.gen(t),r=`${n.varKeyword} ${a} = ${i.variable};\\n`;return n.emit(r,a,i)},Ke={min:0,max:1},Ce=(e,t=0,n=Ke)=>o((a=>{let i=n.max-n.min;return _e(\"phasor\",accum(y(b(e,i),a.sampleRate),t,n))(a)})),cycle=(t,n=0)=>o((a=>{let i=a.gen(t),r=a.gen(n),s=W($(Ce(t),n),0,1)(a),[o,l,m,d,h]=a.useVariables(\"floatIndex\",\"frac\",\"clerp\",\"index\",\"nextIndex\");const c=a.target===e.C?\"sineTable\":\"this.sineTable\";let p=a.intKeyword,b=a.varKeyword,y=a.target===e.C?u[\"Math.floor\"]:\"Math.floor\",f=`\\n${s.code}\\n${a.varKeyword} ${o} = ${s.variable} * 1024;\\n${a.varKeyword} ${l} = ${o} - ${y}(${o});\\n${p} ${d} = ${y}(${o});\\n${p} ${h} = ${d} + 1;\\nif (${h} >= 1024) {\\n  ${h} = 0;\\n}\\n${b} ${m} = (1.0-${l})*${c}[${d}] + ${l}*${c}[${h}];\\n`;return a.emit(f,m,i,r)})),Ee=()=>{let e,t,n,a=[],i=o((i=>{let r=i!==t;t=i,(void 0===e||r)&&(e=i.alloc(1),n=i.useVariables(\"clickVal\")[0],a=a.filter((e=>!e.context.disposed)),a.push({block:e,context:i}));let s=`\\n${i.varKeyword} ${n} = memory[${e.idx}];\\nif (${n} > 0) {\\n   memory[${e.idx}] = 0;\\n}\\n`;return i.emit(s,n)}));return i.click=(e,t)=>{for(let{context:n,block:i}of a)n.postMessage({type:void 0!==e?\"schedule-set\":\"memory-set\",body:{idx:i.idx,value:void 0===t?1:t,time:e}})},i},Se=(e,t)=>o((n=>{const a=ie(),i=B(e,a(),t);return _e(\"onepole\",a(i))(n)})),Ie=(e,t,n)=>o((a=>{let i=gt(F(1,Kt(B(n,t,e))));return _e(\"vactrol\",Se(e,i))(a)})),Ve=(e,...t)=>o((n=>{let a=n.gen(e),i=t.map((e=>n.gen(e))),[r]=n.useVariables(\"selector\"),s=`${n.varKeyword} ${r} = ${a.variable} <= 0 ? 0.0 : (${a.variable} <= 1 ? ${i[0].variable} : (${a.variable} >= ${i.length} ? ${i[i.length-1].variable} : ${i.map(((e,t)=>`${a.variable} == ${t+1} ? ${e.variable} : `)).join(\"\")} 0.0));`;return n.emit(s,r,a,...i)})),Ae=(e,t,n,a,i)=>o((r=>{let s=ie(),o=ie(),l=ie(),u=ie(),m=s(o()),d=l(u()),h=l(u()),p=$(i,1),f=E(t),g=b(f,.00014247585730565955),v=z(g),x=b(v,-1),w=$(x,1),M=y(w,2),_=c(x,1),K=y(_,-2),C=V(g),S=b(C,.5),I=E(n),A=y(S,I),T=b(A,-1),k=b(A,I),O=b(k,-1),j=$(A,1),P=Ve(p,M,K,T,O,1,j),L=H(j),D=b(L,a),R=b(P,D),N=b(h,R),F=e,q=u(e),B=b(x,2),W=Ve(p,w,_,0,0,B,B),Z=b(W,D),G=b(u(),Z),U=J(A,1),Q=Ve(p,M,K,A,k,1,U),X=b(Q,D),Y=b(F,X),ee=$(pt(pt(d),N),pt(pt(q),G),Y),te=s(o()),ne=b(U,L),ae=b(te,ne),re=b(B,L),se=b(o(),re),oe=$(pt(pt(m),ae),se),le=c(ee,oe),ue=o(le),me=o(le);return _e(\"biquad\",pt(m,ue,q,d,me))(r)})),ze=(e,t,n,a,i)=>o((r=>{let s=ie(),o=ie(),l=ie(),u=ie(),m=s(o()),d=e,h=$(i,1),p=E(t),f=b(p,.00014247585730565955),g=z(f),v=b(g,-1),x=$(v,1),w=y(x,2),M=c(v,1),_=y(M,-2),K=V(f),C=b(K,.5),S=E(n),I=y(C,S),A=b(I,S),T=J(I,1),k=Ve(h,w,_,I,A,1,T),O=$(I,1),j=H(O),P=b(j,a),L=b(k,P),D=b(d,L),R=l(e),N=b(v,2),F=Ve(h,x,M,0,0,N,N),q=b(F,P),B=b(l(),q),W=u(l()),Z=b(I,-1),G=b(A,-1),U=Ve(h,w,_,Z,G,1,O),Q=b(U,P),X=b(Q,u()),Y=$(D,pt(pt(R),B),pt(pt(W),X)),ee=b(N,j),te=b(o(),ee),ne=c(Y,te),ae=b(T,j),re=b(ae,s()),se=o(c(ne,pt(pt(m),re)));return pt(m,se,R,W,se)(r)})),Te=(e,t,n,a)=>o((i=>{let r=ie(),s=ie(),o=e,l=b(t,.7853981633974483),u=A(l),m=$(u,1),d=y(u,m),h=H(n),p=$(d,h),f=b(s(),p),g=$(r(),f),v=c(o,g),x=b(d,d),w=b(d,h),M=$(x,w),_=$(M,1),K=H(_),C=b(v,K),E=b(C,d),S=$(E,s()),I=b(S,d),V=$(I,r()),z=r($(V,I)),T=s($(E,S)),k=ve(a,pt(pt(z),V),C,pt(pt(T),S));return pt(z,T,k)(i)})),ke=e=>t=>{let n=t.gen(e),a=`\\nif (${n.variable}) {\\n  break;\\n}\\n`;return t.emit(a,\"\",n)},Oe=(e,t,n,a,i=.01,r=.05)=>{const s=b(20,j(F(E(e),1e-5))),o=D(y(k(.01),b(i,44100))),l=D(y(k(.01),b(r,44100))),u=c(s,n),m=$(u,b(.5,a)),d=mt(v(u,b(-.5,a)),mt(f(u,b(.5,a)),b(y(c(t,1),b(2,a)),b(m,m)),b(u,c(t,1))),0),h=ie();return pt(h(mt(v(d,h()),$(b(o,h()),b(d,c(1,o))),$(b(l,h()),b(d,c(1,l))))),b(q(e),(p=c(s,h()),P(10,y(p,20)))));var p},je=(e=1,t=1,n,a,i)=>{let r,s,o,l=[],u=!1,m=i=>{u=!0,o&&(n=o);let m=i;if(void 0===r||s!==i){if(a)for(;\"context\"in m;)m=m.context;i=m,(!r||i.context!==s&&s.context!==i)&&(i===s||(r=i.alloc(e*t))),r.initData=n,r.length=e,r.channels=t,l.push({block:r,context:i})}return s=i,r.channels=t,r.length=e,null!=n&&(r.initData=n),i.memory.blocksInUse.push(r),r};return m.get=()=>r?r.get():new Promise((e=>e(new Float32Array(1)))),m.interpolation=void 0===i?\"linear\":i,m.getSize=()=>e,m.getChannels=()=>t,m.getInitData=()=>n,m.set=(e,t)=>{o=e;for(let{context:n,block:a}of l)a.initData=e,n.postMessage({type:\"init-memory\",body:{idx:a.idx,data:e,time:t}})},m},Pe=(t,n,a,i)=>o((r=>{let s=r,o=r;for(;\"context\"in r;)r=r.context;let l,m=t(r),$=s.gen(n),d=s.gen(a),[h,c,p,b,y,f,g,v]=s.useVariables(\"preIdx\",\"peekIdx\",\"peekVal\",\"channelIdx\",\"frac\",\"nextIdx\",\"peekIdx_2\",\"peekIdx_3\"),x=m.length,w=(m.length,m.length);i&&(l=s.gen(i),w=l.variable);let M=void 0===m._idx?m.idx:m._idx,_=r.intKeyword,K=r.varKeyword,C=r.target===e.C?u[\"Math.floor\"]:\"Math.floor\",E=`\\n${K} ${h} = ${$.variable};\\nif (${h} > ${m.length} - 1) ${h} = 0; //${m.length};\\nelse if (${h} < 0) ${h} += ${m.length};\\n${_} ${b} = ${d.variable};\\nif (${b} > ${m.channels}) ${b} -= ${m.channels};\\nelse if (${b} < 0) ${b} += ${m.channels};\\n${K} ${c} = ${x} * ${b} + ${h};\\n${K} ${y} = ${c} - ${C}(${c});\\n${_} ${f} = ${C}(${c}) + 1;\\nif (${f} >= ${x} * (${d.variable} + ${w})) {\\n   ${f} =  ${x} * (${d.variable});\\n}\\n${_} ${g} = ${M} + ${C}(${c});\\n${_} ${v} = ${M} + ${f};\\n${K} ${p} = (1 - ${y})*memory[${g}] + (${y})*memory[${v}];\\n`;return\"none\"===t.interpolation&&(E=`\\n${_} ${h} = ${$.variable};\\nif (${h} > ${m.length}) ${h} -= ${m.length};\\nelse if (${h} < 0) ${h} += ${m.length};\\n${_} ${b} = ${d.variable};\\nif (${b} > ${m.channels}) ${b} -= ${m.channels};\\nelse if (${b} < 0) ${b} += ${m.channels};\\n${_} ${c} = ${x} * ${b} + ${h};\\n${_} ${g} = ${M} + ${c};\\n${K} ${p} = memory[${g}];\\n`),l?r.emit(E,p,$,d,l):o.emit(E,p,$,d)})),Le=(t,n,a,i)=>o((r=>{let s=t(r),o=r.gen(n),[l]=r.useVariables(\"pokeIdx_2_\"),m=r.gen(a),$=r.gen(i),d=s.length,h=r.intKeyword,c=(r.varKeyword,r.target===e.C?u[\"Math.floor\"]:\"Math.floor\"),p=`${d} * ${m.variable} + ${c}(${o.variable})`,b=`\\n// begin poke\\n${h} ${l} = ${s._idx||s.idx} + ${p};\\nmemory[${l}] = ${$.variable};\\n// end poke\\n`;return r.emit(b,$.variable,o,m,$)})),De=(t,n)=>o((a=>{let i=t(a),[r]=a.useVariables(\"pokeIdx_2_\"),s=a.gen(n),o=i.length,l=a.intKeyword,m=(a.target===e.C&&u[\"Math.floor\"],`\\nfor (${l} i=0; i < ${o}; i++) {\\n   memory[${i._idx||i.idx} + i] = ${s.variable};\\n}\\n${l} ${r} = ${i._idx||i.idx} + 0;\\n`);return a.emit(m,s.variable,s)})),Re=e=>o((t=>{let n=ie();return c(e,n(e))(t)})),Ne=e=>o((t=>{let n=ie();return q(c(e,n(e)))(t)})),Fe=e=>o((t=>{let n=ie()(e);return f(0,Ne(f(.5,E(y(c(e,n),$(e,n))))))(t)})),qe=(t,n)=>{let a=je(176401,1);return o((i=>{let r=a(i),s=i.gen(t),o=i.gen(n),[l,m,$]=i.useVariables(\"delayVal\",\"index\",\"delayIndex\"),d=accum(1,0,{min:0,max:176400,exclusive:!0})(i),h=`${r.idx} + (${d.variable})`,c=((t,n,a,i=\"memory\")=>{let r=t.idx++,s=`frac${r}`,o=`lerpVal${r}`,l=`nextIdx${r}`,m=`flooredName${r}`,$=t.target===e.C?u[\"Math.floor\"]:\"Math.floor\";return{params:[],code:`\\n/** lerp begin **/\\n${t.varKeyword} ${s} = ${a} - ${$}(${a});\\n${t.target===e.C?\"int\":\"let\"} ${m} = ${$}(${a});\\n${t.target===e.C?\"int\":\"let\"} ${l} = ${m} + 1;\\nif ((${l}) - (${n.idx}) >= ${n.length} - 1) ${l} = ${n.idx};\\n${t.varKeyword} ${o} = (1.0-${s})*${i}[${m}] + ${s}*${i}[${l}];\\n//${t.varKeyword} ${o} = ${i}[${m}];\\n/** lerp end **/\\n`,variable:o,histories:[],functions:[],variables:[o],functionArguments:[]}})(i,r,$),p=`\\n// delay code\\n${d.code}\\n${i.target===e.C?\"int\":\"let\"} ${m} = ${h};\\nmemory[${m}] = ${s.variable};\\n${i.target===e.C?\"double\":\"let\"} ${$} = ${m} - ${o.variable};\\nif (${$} < ${r.idx}) {\\n  ${$} += 176400;\\n} else if (${$} >= ${r.idx} + ${r.length} - 1) {\\n  ${$} -= 176400;\\n}\\n${c.code}\\n${i.varKeyword} ${l} = ${c.variable};\\n`;return i.emit(p,l,s,o)}))},Be=(e,t=0)=>o((n=>{let[a]=n.useVariables(\"latchVal\"),i=n.gen(e),r=n.gen(t),s=n.alloc(1),o=`${n.varKeyword} ${a} = memory[${s.idx}];\\nif (${r.variable} > 0) {\\n  memory[${s.idx}] = ${i.variable};\\n  ${a} = memory[${s.idx}];\\n}`;return n.emit(o,a,i,r)})),We=(e,t,n)=>e.split(t).join(n);var Ze=function(e,t,n,a){return new(n||(n=Promise))((function(i,r){function s(e){try{l(a.next(e))}catch(e){r(e)}}function o(e){try{l(a.throw(e))}catch(e){r(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}l((a=a.apply(e,t||[])).next())}))};const He=(t,n,a=\"Zen\",i=!1)=>new Promise((r=>Ze(void 0,void 0,void 0,(function*(){let{code:s,wasm:o}=Je(a,n),l=s;console.log(l);const u=`data:application/javascript;base64,${btoa(l)}`,m=()=>{const s=new AudioWorkletNode(t,a,{channelInterpretation:\"discrete\",numberOfInputs:n.numberOfInputs,numberOfOutputs:1,channelCount:n.numberOfOutputs,outputChannelCount:[n.numberOfOutputs]});return console.log(\"on compilation complete=\",s),s.port.onmessage=t=>{let a=t.data.type,i=t.data.body;n.context.onMessage({type:a,body:i}),n.context.target===e.C&&\"wasm-ready\"===a&&(at(n.context,s),s.port.postMessage({type:\"ready\"}))},n.context.target===e.C?fetch(\"http://localhost:7171/compile\",{method:\"POST\",headers:{\"Content-Type\":\"text/plain\"},body:o}).then((e=>Ze(void 0,void 0,void 0,(function*(){let t=yield e.arrayBuffer();yield WebAssembly.compile(t),s.port.postMessage({type:\"load-wasm\",body:t})})))):(at(n.context,s),s.port.postMessage({type:\"ready\"})),n.context.addWorklet(s),i||r({code:l,workletNode:s}),s};console.log(\"adding audio worklet to module\",t),yield t.audioWorklet.addModule(u),console.log(\"successfully added worklet to module\"),i?r(m):m()})))),Je=(t,n)=>{let a=[],i=\"@beginMessage\",r=\"@endMessage\",s=n.code.indexOf(i),o=1;for(;s>-1;){let t=n.code.indexOf(r);if(-1===t)break;let l=n.code.slice(s+i.length,t);a.push(l),n.context.target===e.C?n.code=n.code.slice(0,s)+\"\"+o+++n.code.slice(t+r.length):n.code=n.code.slice(0,s)+\"this.messageKey\"+o+++n.code.slice(t+r.length),s=n.code.indexOf(i)}let l=\"\";o=1;for(let e of a)l+=`this.messageKey${o} = \"${e}\";\\n`,l+=`this.messageKeys[${o-1}] = \"${e}\";\\n`,o++;const{code:u,wasm:m}=Ge(n);return{code:`\\nclass ${t}Processor extends AudioWorkletProcessor {\\n\\n  async loadWASM(wasmBuffer) {\\nthis.port.postMessage({type: \"load wasm called\",body: \"yo\"});\\ntry {\\n    const wasmModule = await WebAssembly.compile(wasmBuffer);\\nthis.port.postMessage({type: \"compile completed\",body: \"yo\"});\\n    const importObject = {\\n    env: {\\n      memory: new WebAssembly.Memory({ initial: 256, maximum: 256 })\\n    },\\n GOT: {\\n    mem: {}\\n  }\\n   };\\n    \\nthis.port.postMessage({type: \"initing wasm\",body: \"yo\"});\\n    const wasmInstance = await WebAssembly.instantiate(wasmModule, importObject);\\n    this.wasmModule = wasmInstance;\\n    this.elapsed = 0;\\nthis.port.postMessage({type: \"init succesfful for wasm\",body: \"yo\"});\\n\\n    const BLOCK_SIZE = 128;\\n    this.inputPtr = wasmInstance.exports.my_malloc(BLOCK_SIZE * 4 * ${n.numberOfInputs});\\n    this.input = new Float32Array(wasmInstance.exports.memory.buffer, this.inputPtr, BLOCK_SIZE * ${n.numberOfInputs});\\n    this.outputPtr = wasmInstance.exports.my_malloc(BLOCK_SIZE * 4 * ${n.numberOfOutputs});\\n    this.output = new Float32Array(wasmInstance.exports.memory.buffer, this.outputPtr, BLOCK_SIZE * ${n.numberOfOutputs});\\n    this.port.postMessage({type: \"wasm-ready\"});\\n    this.wasmModule.exports.initSineTable();\\n} catch ( E) {\\nthis.port.postMessage({type: \"error-compiling\", data: \"yo\"});\\n}\\n  }\\n\\n  constructor() {\\n    super();\\n    this.ready = false;\\n    this.counter=0;\\n    this.messageCounter = 0;\\n    this.disposed = false;\\n    this.id = \"${t}\";\\n    this.events = [];\\n    this.messageKey = { type: '', subType: '' };\\n    this.messageQueue = {}; // Map of type/subType -> array of messages\\n    this.lastMessageTime = new Map(); // Map of type/subType -> last message time\\n    this.messageInterval = 100; // Minimum interval between messages for a given type/subType (in milliseconds)\\n\\n    ${nt(\"    \",tt(n))}\\n\\n    this.messageKeys = [];\\n    ${l}\\n\\n    this.createSineTable();\\n    \\nthis.port.postMessage({type: \"ack\",body: \"yo\"});\\n\\n \\n    this.port.onmessage = (e) => {\\n       if (e.data.type === \"memory-set\") {\\n         let {idx, value} = e.data.body;\\n         if (this.wasmModule) {\\n           this.wasmModule.exports.setMemorySlot(idx, value);\\n         } else {\\n            this.memory[idx] = value;\\n         }\\n       } else if (e.data.type === \"load-wasm\") {\\n          this.loadWASM(e.data.body);\\n       } else if (e.data.type === \"schedule-set\") {\\n         let {idx, value, time} = e.data.body;\\n         this.events.push(e.data.body);\\n       } else if (e.data.type === \"init-memory\") {\\n         let {idx, data, time} = e.data.body;\\n         if (this.wasmModule) {\\n           for (let i=0; i < data.length; i++) {\\n             if (time) {\\n               this.events.push({idx: idx+i, value: data[i], time});\\n             } else {\\n               this.wasmModule.exports.setMemorySlot(idx + i, data[i]);\\n             }\\n           }\\n         } else {\\n//           for (let i=0; i < data.length; i++) {\\nif (this.memory) {\\n            this.memory.set(data, idx)\\n}\\n//         }\\n}\\n       } else if (e.data.type === \"memory-get\") {\\n           if (this.wasmModule) {\\n             const memPointer = this.wasmModule.exports.get_memory();\\n             const memArray  = new Float32Array(this.wasmModule.exports.memory.buffer, memPointer , this.memory.length * 3);\\n             let {idx, allocatedSize} = e.data.body;\\n             this.port.postMessage({\\n               type: \"memory-get\",\\n               body: memArray.slice(idx, idx+allocatedSize)\\n             });\\n             \\n           } else {\\n             let {idx, allocatedSize} = e.data.body;\\n             this.port.postMessage({\\n               type: \"memory-get\",\\n               body: this.memory.slice(idx, idx+allocatedSize)\\n             });\\n           }\\n       } else if (e.data.type === \"dispose\") {\\n           this.disposed = true;\\n           this.memory = null;\\n       } else if (e.data.type === \"ready\") {\\n           this.ready = true;\\n       }\\n    }\\n  }\\n\\n  createSineTable() {\\n    const sineTableSize = 1024; // Choose a suitable size for the table, e.g., 4096 \\n    this.sineTable = new Float32Array(sineTableSize);\\n\\n    for (let i = 0; i < sineTableSize; i++) {\\n      this.sineTable[i] = Math.sin((2 * Math.PI * i) / sineTableSize);\\n    }\\n  }\\n\\n  toDelete = [];\\n  scheduleEvents(time=1) {\\n      this.toDelete.length = 0; \\n      for (let event of this.events) {\\n          let idx = event.idx;\\n          let value = event.value;\\n          event.time -= time;\\n          if (event.time <= 0) {\\n             if (this.wasmModule) {\\n                this.wasmModule.exports.setMemorySlot(idx, value);\\n             } else {\\n               this.memory[idx] = value;\\n             }\\n             this.toDelete.push(event);\\n          }\\n     }\\n     if (this.toDelete.length > 0) {\\n        for (let event of this.toDelete) {\\n           let index = this.events.indexOf(event);\\n           this.events.splice(index, 1);\\n        } \\n     }\\n  }\\n\\n   flushWASMMessages() {\\n      if (!this.wasmModule) {\\n         return;\\n      }\\n      let numMessages = this.wasmModule.exports.get_message_counter();\\n      const messageArrayPtr = this.wasmModule.exports.flush_messages();\\n      const messageArray = new Float32Array(this.wasmModule.exports.memory.buffer, messageArrayPtr, 1000 * 24);\\n      let messages = {\\n       };\\n      let heap32 = new Int32Array(this.wasmModule.exports.memory.buffer);\\n      let heapF64 = new Float64Array(this.wasmModule.exports.memory.buffer);\\nlet ids = [];\\nlet keys = [];\\n      for (let i=0; i < numMessages*24; i+=24) {\\n          let messagePtr = messageArrayPtr + i; \\n          let _type = heap32[messagePtr / 4] - 1;\\n          let subType = heapF64[(messagePtr + 8) / 8];\\n          let body = heapF64[(messagePtr + 16) / 8];\\n\\n         let type = this.message";
    }

    function getData() public view returns  (string memory) {
        return data;
    }
}
